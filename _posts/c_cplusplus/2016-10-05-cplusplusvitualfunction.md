---
layout: post
title: "C++虚函数与纯虚函数"
date: 2016-10-05 10:25:30 +0800
comments: true
tags: [C/C++]
---

<!-- cplusplusvitualfunction.md --- 
;; 
;; Description: 
;; Author: Hongyi Wu(吴鸿毅)
;; Email: wuhongyi@qq.com 
;; Created: 三 10月  5 10:25:30 2016 (+0800)
;; Last-Updated: 六 10月 29 12:00:31 2016 (+0800)
;;           By: Hongyi Wu(吴鸿毅)
;;     Update #: 4
;; URL: http://wuhongyi.cn -->


# 什么是虚函数、纯虚函数、抽象基类

虚函数：在某基类中声明为 virtual 并在一个或多个派生类中被重新定 义的成员函数。  
纯虚函数：是一种特殊的虚函数，使用virtual关键字，并且在其后面加上=0。  
抽象基类：在基类中加入至少一个纯虚函数，使基类成为抽象类。

虚函数的作用：每个类必须提供一个可以被调用的虚函数，但每个类可以按它们认为合适的任何方式处理。如果某个类不想做什么特别的事，可以借助于基类中提供的缺省处理函数。也就是说，虚函数的声明是在告诉子类的设计者，"你必须支持虚函数，但如果你不想写自己的版本，可以借助基类中的缺省版本。
<!--more-->
纯虚函数的作用：让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。


面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承、动态绑定。通过数据抽象，可以使类的接口与实现分离，使用继承，可以更容易地定义与其他类相似但不完全相同的新类，使用动态绑定，可以在一定程度上忽略相似类的区别，而以统一的方式使用它们的对象。

虚函数的作用是实现多态性（Polymorphism），多态性是将接口与实现进行分离，采用共同的方法，但因个体差异而采用不同的策略。纯虚函数则是一种特殊的虚函数。虚函数联系到多态，多态联系到继承。

# 虚函数

## 定义

在C++中，基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数；另一种是基类希望派生类直接继承而不要改变的函数。对于前者，基类通过在函数之前加上virtual关键字将其定义为虚函数（virtual）。

```cpp
class Base{ // 基类 
public: 
  virtual int func(int n) const; 
}; 
  
class Derive_Class : public Base{ 
public: 
  int func(int n) const; // 默认也为虚函数 
};
```

当我们在派生类中覆盖某个函数时，可以在函数前加virtual关键字。然而这不是必须的，因为一旦某个函数被声明成虚函数，则所有派生类中它都是虚函数。任何构造函数之外的非静态函数都可以是虚函数。派生类经常（但不总是）覆盖它继承的虚函数，如果派生类没有覆盖其基类中某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。

## 动态绑定

当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定（dynamic binding）。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，可能是基类中的版本也可能是派生类中的版本，判断的依据是引用（或指针）所绑定的对象的真实类型。与非虚函数在编译时绑定不同，虚函数是在运行时选择函数的版本，所以动态绑定也叫运行时绑定（run-time binding）。

## 静态类型与动态类型

静态类型指的是变量声明时的类型或表达式生成的类型，它在编译时总是已知的；动态类型指的是变量或表达式表示的内存中的对象的类型，它直到运行时才可知。当且仅当通过基类的指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

## final和override

派生类中如果定义了一个函数与基类中虚函数同名但形参列表不同，编译器会认为这是派生类新定义的函数。如果我们的意图本是覆盖虚函数，则这种错误很难发现。通过在派生类中的虚函数最后加override关键字使得意图更加清晰。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报错。

```cpp
class Base{ // 基类 
public: 
  virtual int func(int a, int b) const; 
}; 
  
class Derive_Class : public Base{ 
public: 
  int func(int a) const override; // 报错，没有覆盖虚函数 
}; 
```

如果我们定义一个类，并不希望它被继承。或者希望某个函数不被覆盖，则可以把类或者函数指定为final，则之后任何尝试继承该类或覆盖该函数的操作将引发错误。

```cpp
class Base final { /*  */ };   // 基类不能被继承 
class Derive_Class : public Base { /* */ };   // 报错 
  
void func(int) const final;  // 不允许后续的其他类覆盖func(int)
```

## 回避虚函数的机制

在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。可以使用作用域运算符实现这一目的。

```cpp
// 强行调用基类中定义的函数版本而不管baseP的动态类型是什么 
int a = baseP->Base::func(42); 
```

如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。

----

# 纯虚函数

## 定义

为了方便使用多态特性，我们常常需要在基类中定义虚函数。在许多情况下，在基类中不能对虚函数给出有意义的实现。为了让虚函数在基类什么也不做，引进了“纯虚函数”的概念，使函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写=0就可以将一个虚函数说明为纯虚函数（pure virtual）。其中，=0只能出现在类内部的虚函数声明语句处：

```cpp
class Base{ // 抽象基类 
public: 
  virtual int func(int n) const =0; 
}; 
```

需要注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。

## 抽象基类

含有（或者未经覆盖直接继承）纯虚函数的类叫抽象基类（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象基类。因为抽象基类含有纯虚函数（没有定义），所以我们不能创建一个抽象基类的对象，但可以声明指向抽象基类的指针或引用。

```cpp
Base base;  // 错误，不能实例化抽象基类
```



----

本文来自：

> http://www.jb51.net/article/53738.htm

<!-- cplusplusvitualfunction.md ends here -->
